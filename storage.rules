rules_version = '2';

// Craft rules based on data ownership in your Firestore database
service firebase.storage {
  match /b/{bucket}/o {
    
    // ========================================================================
    // HELPERS
    // ========================================================================
    
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isAdmin() {
       // We can't access Firestore directly from Storage rules easily in all versions without specific setup,
       // but we can check custom claims if set.
       // For simplicity and standard usage without claims:
       // We assume admins are handled via backend or we trust specific UIDs if hardcoded (not ideal).
       // BETTER: Use Firestore Auth Claims. If not available, we might limit write to known paths.
       // For now, let's assume `request.auth.token.admin == true` OR allow if we can verify via path logic.
       // FALLBACK: Since we can't easily read Firestore from Storage rules, we will restrict critical writes 
       // to authenticated users for their own data, and open public reads.
       // Admin-only writes (like products) ideally should go through a backend or have a specific Custom Claim.
       // Assuming 'admin' claim is set on the token for admins.
       return request.auth.token.role == 'admin' || request.auth.token.admin == true;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isImage() {
      return request.resource.contentType.matches('image/.*');
    }

    function isSmallFile() {
      return request.resource.size < 5 * 1024 * 1024; // 5MB limit
    }

    // ========================================================================
    // RULES
    // ========================================================================

    // 1. PRODUCTS & SERVICES IMAGES (Catalog)
    // Path: /products/{productId}/{fileName}
    match /products/{allPaths=**} {
      allow read: if true;
      // Only admins should upload product images
      // If no custom claims, you might need to rely on backend upload or strict path checking if you trust specific UIDs.
      // We'll enforce 'admin' claim or check if user is authenticated (less secure if any user can upload).
      // Let's be strict: require admin claim.
      allow write: if isAdmin() && isImage() && isSmallFile();
    }
    
    match /services/{allPaths=**} {
      allow read: if true;
      allow write: if isAdmin() && isImage() && isSmallFile();
    }
    
    match /projects/{allPaths=**} {
      allow read: if true;
      allow write: if isAdmin() && isImage() && isSmallFile();
    }

    // 2. USER AVATARS
    // Path: /users/{userId}/avatar.jpg
    match /users/{userId}/{fileName} {
      allow read: if true; // Public profiles usually have public avatars
      allow write: if isOwner(userId) && isImage() && isSmallFile();
    }

    // 3. ORDER ATTACHMENTS (e.g. custom design files)
    // Path: /orders/{orderId}/{fileName}
    match /orders/{orderId}/{fileName} {
      // Read: Owner of order (need to match ID logic) or Admin
      // Storage doesn't know who owns orderId. 
      // Strategy: Use folder structure /users/{userId}/orders/{orderId}/...
      // OR allow if auth.uid is part of metadata (if client sets it).
      // SAFEST: Store user files under /users/{userId}/...
      allow read: if isAdmin(); // Default restrictive
    }
    
    // User uploads for orders should go to their user folder
    // match /users/{userId}/uploads/{fileName}
    match /users/{userId}/uploads/{fileName} {
      allow read: if isOwner(userId) || isAdmin();
      allow write: if isOwner(userId) && request.resource.size < 50 * 1024 * 1024; // 50MB for 3D files
    }

    // Default deny
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}
